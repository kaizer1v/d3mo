<!--
This is an experiment on using d3's force layout. I am using our team as the data set.

TODO
0. Initial setup, put all the circles in a group, with collision detection
1. Add a tooltip, photo and other details
2. Add filters to group by different properties, these should be extracted
3. Use photo as the circle
4. Add background map of India for `from` property

-->
<html>
<head>
  <style>
    svg {
      border: 1px solid #000;
      background-color: beige;
    }
    </style>
</head>
<body>

  <h1>Force Layout</h1>
  <button id="by-hub">Group by Hub</button>
  <button id="by-from">Group by where they are from</button>

  <input type="range" id="charge" min="-10" max="100" value="30" step="1" />
  <label for="charge">Radial Charge</label>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
  // create an svg element
  const svg = d3.select('body')
    .selectAll('svg')
    .data([null])
    .join('svg')
    .attr('width', '90vh')
    .attr('height', '90vh')
  
  const svg_width = svg._groups[0][0].clientWidth
  const svg_height = svg._groups[0][0].clientHeight  
  svg.attr('viewBox', [-svg_width/2, -svg_height/2, svg_width, svg_height])

  /**
   * given a set of grouped data, generate centers coordinates for each group
   * in the canvas that is spaced out
   * 
   * @param {Array} data - the data set
   * @param {String} key - the key to group by
   */
  function generate_centers(data, key) {
    const centers = []
    const groups = data.reduce((acc, d) => {
      // if nested structure, then split and reduce
      const keyValue = key.split('.').reduce((obj, k) => (obj && obj[k] !== undefined) ? obj[k] : null, d)
      if (!acc[keyValue]) acc[keyValue] = []
      acc[keyValue].push(d)
      return acc
    }, {})

    const keys = Object.keys(groups)
    const angle = 2 * Math.PI / keys.length

    keys.forEach((k, i) => {
      centers.push({
        name: k,
        x: 200 * Math.cos(angle * i),
        y: 200 * Math.sin(angle * i)
      })
    })

    return centers
  }

  // data
  const nodes = d3.json('data/ux_team.json')
    .then(data => data.data)
    .then(data => load_force(data))
    .catch(err => console.error(err)) 


/**
 * given a set of nodes, create a force layout
 * 
 * @param {Array} nodes - the data set 
 */
function load_force(nodes) {

  const hub_centres = generate_centers(nodes, 'hub')
  const location_centres = generate_centers(nodes, 'from.state')

  // background image to circles
  const defs = svg.append('svg:defs')

  defs.append('svg:pattern')
    .selectAll('pattern')
    .data(nodes)
    .enter()
    .append('svg:pattern')
    .attr('id', (d) => d.name.toLowerCase() + '_avatar')
    .attr('width', 1)
    .attr('height', 1)
    .append('svg:image')
    .attr('xlink:href', (d => `data/photos/${d.name.toLowerCase()}.jpg`))
    .attr('width', 40)
    .attr('height', 40)
    .attr('x', 0)
    .attr('y', 0)


  // add each circle for a data point
  const node = svg.append('g')
    .selectAll('circle')
    .data(nodes)
    .enter()
    .append('circle')
    .attr('r', 20)
    .attr('stroke', 'black')
    .attr('stroke-width', 1)
    .attr('fill', (d) => { return d['hub'] === 'logistics' ? 'steelblue' : 'orange' })
    .style('fill', (d) => `url(#${d.name.toLowerCase()}_avatar)`)


  // simulate a force and describe how it should behave
  const simulation = d3.forceSimulation(nodes)
    // .force('x', d => d3.forceX(d.x))    // use the property of x set by the force set by the forceSimualtion function
    // .force('y', d => d3.forceY(d.y))
    .force('charge', d3.forceManyBody().strength(0))
    .force('collide', d3.forceCollide(21))    // avoid overlapping (11 = radius + 1)
  
  // run the simulation for every 'tick'
  // this is for every frame of the simulation, you need to position the circle
  simulation.on('tick', () => {
    node
      .attr('cx', d => d.x)
      .attr('cy', d => d.y)
  })


  // controlling force via input
  const charge = document.getElementById('charge')
  charge.addEventListener('input', function() {
    simulation.force('charge', d3.forceRadial(charge.value).strength(0.1))
    simulation.alpha(1).restart()
  })


  /**
   * given a data key, group the data by the key
   * 
   * @param {String} key - the key to group by
   * @param {Array} centres - the centers to group by
   */
  function groupBy(key, centres) {
    simulation.force('x', d3.forceX(d => {
      const center = centres.find(c => c.name === key.split('.').reduce((obj, k) => (obj && obj[k] !== undefined) ? obj[k] : null, d))
      if (!center) return 0
      return center['x']
    }).strength(0.1))

    simulation.force('y', d3.forceY(d => {
      const center = centres.find(c => c.name === key.split('.').reduce((obj, k) => (obj && obj[k] !== undefined) ? obj[k] : null, d))
      if (!center) return 0
      return center['y']
    }).strength(0.1))

    simulation.alpha(1).restart()
  }

  // group by hub
  const by_hub = document.getElementById('by-hub')
  const by_location = document.getElementById('by-from')
  
  by_hub.addEventListener('click', () => groupBy('hub', hub_centres))
  by_location.addEventListener('click', () => groupBy('from.state', location_centres))

  // show tooltip on hover of the svg circle & remove on mouseout
  node.on('mouseout', function() {
    d3.selectAll('.tooltip').remove()
  })
  node.on('mouseover', function(event, d) {
    const tooltip = d3.select('body')
      .append('div')
      .attr('class', 'tooltip')
      .style('position', 'absolute')
      .style('background-color', 'white')
      .style('border', '1px solid black')
      .style('padding', '5px')
      .style('border-radius', '5px')
      .style('opacity', 0.9)
      .style('left', (event.pageX + 10) + 'px')
      .style('top', (event.pageY + 10) + 'px')
      .text(d.name)
  })
}

</script>
</body>
</html>